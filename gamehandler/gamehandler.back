package gamehandler

import (
	"game/BorderMethod"
	"sync"

	"fyne.io/fyne/v2"
	"github.com/AspieSoft/goutil/v5"
)

type CanvasSize struct {
	// RealWidth is the actual window width in pixels
	RealWidth float32

	// RealHeight is the actual window height in pixels
	RealHeight float32

	// Scale is a number based on the smallest dimension used to calculate how objects should be resized based on the screen size
	Scale float32

	// Width is calculated after scaling down
	//
	// for the actual pixel width, use 'RealWidth'
	Width float32

	// Height is calculated after scaling down
	//
	// for the actual pixel height, use 'RealHeight'
	Height float32
}

type ThreadInfo struct {
	FPS uint16
	Frame uint16
}

type Game struct {
	Canvas *fyne.Container
	Window fyne.Window
	Size CanvasSize
	MU sync.Mutex
}


var GameObjectInit []func(game *Game) = []func(game *Game){}

func InitObject(cb func(game *Game)){
	GameObjectInit = append(GameObjectInit, cb)
}

type GameObject struct{
	id string
	name string
	Object fyne.CanvasObject
	MU sync.Mutex

	X float32
	Y float32

	Width float32
	Height float32

	VelX float32
	VelY float32

	// OnBorderX returns -1 or 1 if this object if touching a border in the x axis
	//
	// it will also return -3 or 3 if it is past the border and fully hidden
	//
	// -2 or 2 means we are pushing on a border (moving in that direction)
	//
	// -4 or 4 means we are pushing past a border (moving in that direction)
	OnBorderX int8

	// OnBorderY returns -1 or 1 if this object if touching a border in the y axis
	//
	// it will also return -3 or 3 if it is past the border and fully hidden
	//
	// -2 or 2 means we are pushing on a border (moving in that direction)
	//
	// -4 or 4 means we are pushing past a border (moving in that direction)
	OnBorderY int8

	// BorderMethod allows you to use a preset method on how to handle objects when they touch a border
	//
	// default: Ignore
	BorderMethod uint8

	// Store is a basic map for storing extra data attached to an object if needed
	Store map[string]any

	// PreferredFPS is an optional FPS preference for detection updates for an object
	//
	// example: border detection
	//
	// default: 120
	PreferredFPS uint16

	// Update is an optional method that runs on a normal 60 fps game loop
	//
	// example: updating the player stats
	Update func(game *Game, thread *ThreadInfo)

	// Draw is an optional method that runs on a graphical 120 fps game loop
	//
	// example: drawing data to canvas
	Draw func(game *Game, thread *ThreadInfo)

	// UpdateBasic is an optional method that runs on an extra slow 15 fps game loop
	//
	// this method can be useful for long math operations or things that do not take priority
	//
	// example: updating particals (there could be many of them taking up a lot of the cpu)
	UpdateBasic func(game *Game, thread *ThreadInfo)

	// UpdateSlow is an optional method that runs on a slow 30 fps game loop
	//
	// this methid can be useful when many objects need to update frequently, and the cpu usage needs to be reduced
	//
	// example: updating entity stats (seperating this from the player can prevent input lag)
	UpdateSlow func(game *Game, thread *ThreadInfo)
}

type gameObjectTypes struct {
	object []*GameObject
	partical []*GameObject
	player []*GameObject
	gui []*GameObject

	mu sync.Mutex
}

var gameObjects gameObjectTypes

// game methods
func (game *Game) Add(name string, x, y, width, height float32, cb func(game *Game) fyne.CanvasObject) *GameObject {
	object := GameObject{
		id: string(goutil.Crypt.RandBytes(64)),
		name: name,
		Object: cb(game),

		X: x,
		Y: y,
		Width: width,
		Height: height,
	}

	gameObjectsMU.Lock()
	gameObjects = append(gameObjects, &object)
	game.Canvas.Add(object.Object)
	game.Canvas.Refresh()
	gameObjectsMU.Unlock()

	return &object
}

func (game *Game) Get(name string) []*GameObject {
	list := []*GameObject{}

	for _, object := range gameObjects {
		if object.name == name {
			list = append(list, object)
		}
	}

	return list
}

func (game *Game) GetID(id string) *GameObject {
	for _, object := range gameObjects {
		if object.id == id {
			return object
		}
	}

	return nil
}


// object methods
func (object *GameObject) Remove(game *Game, thread *ThreadInfo){
	gameObjectsMU.Lock()
	game.Canvas.Remove(object.Object)
	for i, obj := range gameObjects {
		if obj.id == object.id {
			gameObjects = append(gameObjects[:i], gameObjects[i+1:]...)
		}
	}
	gameObjectsMU.Unlock()
}

func (object *GameObject) handleBorder(game *Game, thread *ThreadInfo){
	{ // check if object in on or past border
		if object.X + object.Width < -game.Size.Width {
			object.OnBorderX = -3
		} else if object.X - object.Width > game.Size.Width {
			object.OnBorderX = 3
		}else if object.X - object.Width <= -game.Size.Width {
			object.OnBorderX = -1
		}else if object.X + object.Width >= game.Size.Width {
			object.OnBorderX = 1
		}else{
			object.OnBorderX = 0
		}
	
		if object.Y + object.Height < -game.Size.Height {
			object.OnBorderY = -3
		} else if object.Y - object.Height > game.Size.Height {
			object.OnBorderY = 3
		}else if object.Y - object.Height <= -game.Size.Height {
			object.OnBorderY = -1
		}else if object.Y + object.Height >= game.Size.Height {
			object.OnBorderY = 1
		}else{
			object.OnBorderY = 0
		}
	
		if object.VelX < 0 && object.OnBorderX <= -1 {
			object.OnBorderX--
		}else if object.VelX > 0 && object.OnBorderX >= 1 {
			object.OnBorderX++
		}

		if object.VelY < 0 && object.OnBorderY <= -1 {
			object.OnBorderY--
		}else if object.VelY > 0 && object.OnBorderY >= 1 {
			object.OnBorderY++
		}
	}

	// handle object border method
	switch object.BorderMethod {
	case BorderMethod.PushLimit:
		if object.X - object.Width < -game.Size.Width {
			object.X = -game.Size.Width + object.Width
		}else if object.X + object.Width > game.Size.Width {
			object.X = game.Size.Width - object.Width
		}

		if object.Y - object.Height < -game.Size.Height {
			object.Y = -game.Size.Height + object.Height
		}else if object.Y + object.Height > game.Size.Height {
			object.Y = game.Size.Height - object.Height
		}

	case BorderMethod.PushHide:
		if object.X + object.Width < -game.Size.Width {
			object.X = -game.Size.Width - object.Width - 0.25
		}else if object.X - object.Width > game.Size.Width {
			object.X = game.Size.Width + object.Width + 0.25
		}

		if object.Y + object.Height < -game.Size.Height {
			object.Y = -game.Size.Height - object.Height - 0.25
		}else if object.Y - object.Height > game.Size.Height {
			object.Y = game.Size.Height + object.Height + 0.25
		}

	case BorderMethod.Bounce:
		if object.OnBorderX != 0 && object.OnBorderX % 2 == 0 {
			object.VelX *= -1
		}
		if object.OnBorderY != 0 && object.OnBorderY % 2 == 0 {
			object.VelY *= -1
		}

	case BorderMethod.Teleport:
		if object.OnBorderX <= -4 {
			object.X = game.Size.Width + object.Width
		}else if object.OnBorderX >= 4 {
			object.X = -game.Size.Width - object.Width
		}

		if object.OnBorderY <= -4 {
			object.Y = game.Size.Height + object.Height
		}else if object.OnBorderY >= 4 {
			object.Y = -game.Size.Height - object.Height
		}

	case BorderMethod.RemoveObject:
		if object.OnBorderX <= -4 || object.OnBorderX >= 4 || object.OnBorderY <= -4 || object.OnBorderY >= 4 {
			object.Remove(game, thread)
		}
	}
}


// basic methods
func Update(game *Game, thread *ThreadInfo){
	for _, object := range gameObjects {
		if object.PreferredFPS >= 60 && object.PreferredFPS < 120 { 
			object.handleBorder(game, thread)
		}

		if object.Update != nil {
			object.Update(game, thread)
		}
	}
}

func Draw(game *Game, thread *ThreadInfo){
	for _, object := range gameObjects {
		if object.PreferredFPS == 0 || object.PreferredFPS > 120 { 
			object.handleBorder(game, thread)
		}

		// handle object border method
		switch object.BorderMethod {
		case BorderMethod.Ignore:
			object.X += object.VelX / 10
			object.Y += object.VelY / 10

		case BorderMethod.Limit:
			if object.OnBorderX == 0 || object.OnBorderX % 2 != 0 {
				object.X += object.VelX / 10
			}
			if object.OnBorderY == 0 || object.OnBorderY % 2 != 0 {
				object.Y += object.VelY / 10
			}

		case BorderMethod.Hide:
			if object.OnBorderX >= -3 && object.OnBorderX <= 3 {
				object.X += object.VelX / 10
			}
			if object.OnBorderY >= -3 && object.OnBorderY <= 3 {
				object.Y += object.VelY / 10
			}

		case BorderMethod.PushLimit:
			if object.OnBorderX == 0 || object.OnBorderX % 2 != 0 {
				object.X += object.VelX / 10
			}
			if object.OnBorderY == 0 || object.OnBorderY % 2 != 0 {
				object.Y += object.VelY / 10
			}

		case BorderMethod.PushHide:
			if object.OnBorderX >= -3 && object.OnBorderX <= 3 {
				object.X += object.VelX / 10
			}
			if object.OnBorderY >= -3 && object.OnBorderY <= 3 {
				object.Y += object.VelY / 10
			}

		default:
			object.X += object.VelX / 10
			object.Y += object.VelY / 10
		}

		if object.Draw != nil {
			object.Draw(game, thread)
		}

		//todo: adjust math to use center of screen an 0 position (for canvas and objects)

		object.Object.Move(fyne.NewPos(((object.X - object.Width) * game.Size.Scale) + (game.Size.RealWidth/2), ((object.Y - object.Height) * game.Size.Scale) + (game.Size.RealHeight/2)))
		object.Object.Resize(fyne.NewSize((object.Width * 2) * game.Size.Scale, (object.Height * 2) * game.Size.Scale))

		// object.Object.Move(fyne.NewPos(object.X * game.Size.Scale, object.Y * game.Size.Scale))
		// object.Object.Resize(fyne.NewSize(object.Width * game.Size.Scale, object.Height * game.Size.Scale))
		object.Object.Refresh()
	}
}

func UpdateBasic(game *Game, thread *ThreadInfo){
	for _, object := range gameObjects {
		if object.PreferredFPS >= 15 && object.PreferredFPS < 30 { 
			object.handleBorder(game, thread)
		}

		if object.UpdateBasic != nil {
			object.UpdateBasic(game, thread)
		}
	}
}

func UpdateSlow(game *Game, thread *ThreadInfo){
	for _, object := range gameObjects {
		if object.PreferredFPS >= 30 && object.PreferredFPS < 60 { 
			object.handleBorder(game, thread)
		}

		if object.UpdateSlow != nil {
			object.UpdateSlow(game, thread)
		}
	}
}
